// Generates typed TypeScript and Kotlin API clients plus API.md from the Go route declarations.
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
	"unicode"

	"github.com/maruel/caic/backend/internal/server/dto"
	v1 "github.com/maruel/caic/backend/internal/server/dto/v1"
	"github.com/maruel/ksid"
)

// Output directories relative to go:generate CWD (backend/internal/server/dto/v1/).
const (
	sdkDir    = "../../../../../sdk"
	tsDir     = sdkDir + "/ts/v1"
	kotlinDir = sdkDir + "/kotlin/src/main/kotlin/com/caic/sdk/v1"
)

var pathParamRe = regexp.MustCompile(`\{(\w+)\}`)

// isSDKPkg reports whether pkgPath is dto or dto/v1 — the two packages
// whose struct types are emitted into the generated SDK.
func isSDKPkg(pkgPath string) bool {
	return pkgPath == reflect.TypeFor[v1.StatusResp]().PkgPath() ||
		pkgPath == reflect.TypeFor[dto.ErrorResponse]().PkgPath()
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run() error {
	if err := generateTS(tsDir); err != nil {
		return err
	}
	if err := generateKotlin(kotlinDir); err != nil {
		return err
	}
	return generateDoc(sdkDir)
}

// generateTS generates the TypeScript API client (existing behavior).
func generateTS(outDir string) error {
	// Collect all referenced types for the import statement.
	types := map[string]struct{}{}
	for i := range v1.Routes {
		r := &v1.Routes[i]
		if n := r.ReqName(); n != "" {
			types[n] = struct{}{}
		}
		types[r.RespName()] = struct{}{}
	}
	types["ErrorResponse"] = struct{}{}

	sorted := sortedKeys(types)

	var b strings.Builder
	b.WriteString("// Code generated by gen-api-sdk. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "import type { %s } from \"./types.gen\";\n\n", strings.Join(sorted, ", "))

	// APIError class.
	b.WriteString(`export class APIError extends Error {
  constructor(
    public status: number,
    public code: string,
    public details?: Record<string, unknown>,
  ) {
    super(code);
  }
}

`)

	// Generic request helper.
	b.WriteString(`async function request<T>(method: string, path: string, body?: unknown): Promise<T> {
  const init: RequestInit = { method, headers: { "Content-Type": "application/json" } };
  if (body !== undefined) init.body = JSON.stringify(body);
  const res = await fetch(path, init);
  if (!res.ok) {
    const err = (await res.json()) as ErrorResponse;
    const e = new APIError(res.status, err.error.code, err.details);
    e.message = err.error.message;
    throw e;
  }
  return res.json() as Promise<T>;
}

`)

	// One function per route.
	for i := range v1.Routes {
		r := &v1.Routes[i]
		params := extractPathParams(r.Path)
		if r.IsSSE {
			writeTSSSEFunc(&b, r, params)
		} else {
			writeTSJSONFunc(&b, r, params)
		}
	}

	return os.WriteFile(filepath.Join(outDir, "api.gen.ts"), []byte(b.String()), 0o600)
}

func writeTSJSONFunc(b *strings.Builder, r *v1.Route, params []string) {
	respType := r.RespName()
	if r.IsArray {
		respType += "[]"
	}

	// Build function signature.
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	hasReq := r.Req != nil
	if hasReq {
		args = append(args, "req: "+r.ReqName())
	}

	tsPath := buildTSPath(r.Path, params)

	fmt.Fprintf(b, "export function %s(%s): Promise<%s> {\n", r.Name, strings.Join(args, ", "), respType)
	if hasReq {
		fmt.Fprintf(b, "  return request<%s>(%q, %s, req);\n", respType, r.Method, tsPath)
	} else {
		fmt.Fprintf(b, "  return request<%s>(%q, %s);\n", respType, r.Method, tsPath)
	}
	b.WriteString("}\n\n")
}

func writeTSSSEFunc(b *strings.Builder, r *v1.Route, params []string) {
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	tsPath := buildTSPath(r.Path, params)
	respName := r.RespName()
	args = append(args, "onMessage: (event: "+respName+") => void")
	fmt.Fprintf(b, "export function %s(%s): EventSource {\n", r.Name, strings.Join(args, ", "))
	fmt.Fprintf(b, "  const es = new EventSource(%s);\n", tsPath)
	b.WriteString("  es.addEventListener(\"message\", (e) => {\n")
	fmt.Fprintf(b, "    onMessage(JSON.parse(e.data) as %s);\n", respName)
	b.WriteString("  });\n")
	b.WriteString("  return es;\n")
	b.WriteString("}\n\n")
}

// generateKotlin generates Types.kt and ApiClient.kt in outDir.
func generateKotlin(outDir string) error {
	if err := os.MkdirAll(outDir, 0o750); err != nil {
		return err
	}
	if err := writeKotlinTypes(outDir); err != nil {
		return err
	}
	return writeKotlinClient(outDir)
}

// kotlinTypeAlias describes a `typealias X = String` with an optional
// companion object holding constants.
type kotlinTypeAlias struct {
	name      string
	constants []kotlinConstant
}

// kotlinConstant is a single `const val Name: Type = "value"` entry.
type kotlinConstant struct {
	name  string
	value string
}

// kotlinStruct wraps a reflect.Type with an optional section comment that
// appears before the struct in the generated output.
type kotlinStruct struct {
	t       reflect.Type
	comment string // Emitted as `// comment` before the struct.
}

// kotlinField holds parsed information about a single struct field for Kotlin
// code generation.
type kotlinField struct {
	jsonName   string // JSON key from the struct tag.
	ktName     string // Kotlin property name (same as jsonName).
	ktType     string // Kotlin type (e.g. "String", "List<Foo>").
	nullable   bool   // Whether the field is T? = null.
	serialName string // Non-empty when @SerialName annotation is needed.
}

// Type aliases: typealias + companion object with constants.
var kotlinAliases = []kotlinTypeAlias{
	{
		name: "Harness",
		constants: []kotlinConstant{
			{"Claude", string(v1.HarnessClaude)},
			{"Codex", string(v1.HarnessCodex)},
			{"Gemini", string(v1.HarnessGemini)},
		},
	},
	{
		name: "EventKind",
		constants: []kotlinConstant{
			{"Init", string(v1.EventKindInit)},
			{"Text", string(v1.EventKindText)},
			{"TextDelta", string(v1.EventKindTextDelta)},
			{"ToolUse", string(v1.EventKindToolUse)},
			{"ToolResult", string(v1.EventKindToolResult)},
			{"Ask", string(v1.EventKindAsk)},
			{"Usage", string(v1.EventKindUsage)},
			{"Result", string(v1.EventKindResult)},
			{"System", string(v1.EventKindSystem)},
			{"UserInput", string(v1.EventKindUserInput)},
			{"Todo", string(v1.EventKindTodo)},
			{"DiffStat", string(v1.EventKindDiffStat)},
		},
	},
}

// Standalone type alias without constants.
var kotlinStandaloneAliases = []struct {
	name   string
	target string
}{
	{"ClaudeEventKind", "EventKind"},
}

// Error code constants.
var kotlinErrorCodes = []kotlinConstant{
	{"BadRequest", string(dto.CodeBadRequest)},
	{"NotFound", string(dto.CodeNotFound)},
	{"Conflict", string(dto.CodeConflict)},
	{"InternalError", string(dto.CodeInternalError)},
}

// kotlinSectionComments maps type names to section comments emitted before
// the struct in the generated output.
var kotlinSectionComments = map[string]string{
	"EventMessage":       "Backend-neutral event types",
	"ClaudeEventMessage": "Claude-specific event types",
}

// discoverKotlinStructs walks the dto struct types reachable from route
// ReqRT/RespRT fields and returns them in dependency order (leaves first).
func discoverKotlinStructs() []kotlinStruct {
	seen := map[reflect.Type]bool{}
	var order []reflect.Type

	// walk recursively collects dto/v1 struct types in post-order so that
	// referenced types appear before the types that reference them.
	var walk func(t reflect.Type)
	walk = func(t reflect.Type) {
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}
		if t.Kind() == reflect.Slice {
			walk(t.Elem())
			return
		}
		if t.Kind() != reflect.Struct || !isSDKPkg(t.PkgPath()) {
			return
		}
		if seen[t] {
			return
		}
		seen[t] = true
		for i := range t.NumField() {
			walk(t.Field(i).Type)
		}
		order = append(order, t)
	}

	// Seed from route types.
	for i := range v1.Routes {
		r := &v1.Routes[i]
		if r.Req != nil {
			walk(r.Req)
		}
		walk(r.Resp)
	}
	// Always include error types.
	walk(reflect.TypeFor[dto.ErrorResponse]())

	result := make([]kotlinStruct, len(order))
	for i, t := range order {
		result[i] = kotlinStruct{t: t, comment: kotlinSectionComments[t.Name()]}
	}
	return result
}

// Type identity values for special-case mapping in goTypeToKotlin.
var (
	jsonRawMessageType = reflect.TypeFor[json.RawMessage]()
	ksidIDType         = reflect.TypeFor[ksid.ID]()
	diffStatType       = reflect.TypeFor[v1.DiffStat]()
	mapStringAnyType   = reflect.TypeFor[map[string]any]()
)

// kotlinAliasNames is the set of Go named-string types that map to their
// Kotlin typealias name rather than "String".
var kotlinAliasNames = map[reflect.Type]string{
	reflect.TypeFor[v1.Harness]():         "Harness",
	reflect.TypeFor[v1.EventKind]():       "EventKind",
	reflect.TypeFor[v1.ClaudeEventKind](): "ClaudeEventKind",
}

// kotlinPlural returns the plural object name for a type alias.
var kotlinPluralOverrides = map[string]string{
	"Harness": "Harnesses",
}

func kotlinPlural(name string) string {
	if p, ok := kotlinPluralOverrides[name]; ok {
		return p
	}
	return name + "s"
}

// goTypeToKotlin maps a Go reflect.Type to its Kotlin type string.
func goTypeToKotlin(t reflect.Type) string {
	// Unwrap pointer — nullability is handled by the caller.
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	// Special cases.
	switch t {
	case jsonRawMessageType:
		return "JsonElement"
	case ksidIDType:
		return "String"
	case diffStatType:
		return "List<DiffFileStat>"
	case mapStringAnyType:
		return "Map<String, JsonElement>"
	}

	// Named string aliases (Harness, EventKind, ClaudeEventKind).
	if name, ok := kotlinAliasNames[t]; ok {
		return name
	}

	switch t.Kind() {
	case reflect.String:
		return "String"
	case reflect.Int:
		return "Int"
	case reflect.Int64:
		return "Long"
	case reflect.Float64:
		return "Double"
	case reflect.Bool:
		return "Boolean"
	case reflect.Slice:
		return "List<" + goTypeToKotlin(t.Elem()) + ">"
	case reflect.Struct:
		return t.Name()
	default:
		return t.Name()
	}
}

// parseStructFields extracts kotlinField entries from a reflect.Type.
func parseStructFields(t reflect.Type) []kotlinField {
	fields := make([]kotlinField, 0, t.NumField())
	for i := range t.NumField() {
		sf := t.Field(i)
		if !sf.IsExported() {
			continue
		}
		tag := sf.Tag.Get("json")
		if tag == "-" {
			continue
		}
		jsonName, opts := parseJSONTag(tag)
		if jsonName == "" {
			jsonName = sf.Name
		}
		omit := opts.contains("omitempty") || opts.contains("omitzero")

		ft := sf.Type
		isPtr := ft.Kind() == reflect.Ptr

		ktType := goTypeToKotlin(ft)
		nullable := isPtr || (omit && !isPtr)

		sn := ""
		if needsSerialName(jsonName) {
			sn = jsonName
		}

		fields = append(fields, kotlinField{
			jsonName:   jsonName,
			ktName:     jsonName,
			ktType:     ktType,
			nullable:   nullable,
			serialName: sn,
		})
	}
	return fields
}

// needsSerialName returns true when the JSON name contains a run of two or
// more consecutive uppercase ASCII letters (e.g. "repoURL", "sessionID",
// "costUSD", "durationAPIMs"). Kotlin properties use these names as-is, but
// kotlinx.serialization would mangle them without an explicit @SerialName.
func needsSerialName(name string) bool {
	consecutive := 0
	for _, r := range name {
		if unicode.IsUpper(r) {
			consecutive++
			if consecutive >= 2 {
				return true
			}
		} else {
			consecutive = 0
		}
	}
	return false
}

// emitKotlinStruct writes a @Serializable data class to b.
func emitKotlinStruct(b *strings.Builder, t reflect.Type) {
	fields := parseStructFields(t)
	name := t.Name()

	// Compact single-line form for structs with ≤2 fields and no @SerialName.
	if len(fields) <= 2 && !fieldsNeedAnnotation(fields) {
		b.WriteString("@Serializable\n")
		fmt.Fprintf(b, "data class %s(", name)
		for i := range fields {
			if i > 0 {
				b.WriteString(", ")
			}
			writeFieldDecl(b, &fields[i])
		}
		b.WriteString(")\n")
		return
	}

	b.WriteString("@Serializable\n")
	fmt.Fprintf(b, "data class %s(\n", name)
	for i := range fields {
		f := &fields[i]
		b.WriteString("    ")
		if f.serialName != "" {
			fmt.Fprintf(b, "@SerialName(%q) ", f.serialName)
		}
		writeFieldDecl(b, f)
		b.WriteString(",\n")
	}
	b.WriteString(")\n")
}

// writeFieldDecl writes a single "val name: Type" (with optional "? = null").
func writeFieldDecl(b *strings.Builder, f *kotlinField) {
	if f.nullable {
		fmt.Fprintf(b, "val %s: %s? = null", f.ktName, f.ktType)
	} else {
		fmt.Fprintf(b, "val %s: %s", f.ktName, f.ktType)
	}
}

// fieldsNeedAnnotation returns true if any field requires @SerialName.
func fieldsNeedAnnotation(fields []kotlinField) bool {
	for _, f := range fields {
		if f.serialName != "" {
			return true
		}
	}
	return false
}

// parseJSONTag splits a json struct tag value into name and options.
func parseJSONTag(tag string) (string, jsonTagOptions) {
	if name, rest, ok := strings.Cut(tag, ","); ok {
		return name, jsonTagOptions(rest)
	}
	return tag, ""
}

type jsonTagOptions string

func (o jsonTagOptions) contains(opt string) bool {
	s := string(o)
	for s != "" {
		var name string
		name, s, _ = strings.Cut(s, ",")
		if name == opt {
			return true
		}
	}
	return false
}

func writeKotlinTypes(outDir string) error {
	var b strings.Builder
	b.WriteString("// Code generated by gen-api-sdk. DO NOT EDIT.\n")
	b.WriteString("package com.caic.sdk.v1\n\n")
	b.WriteString("import kotlinx.serialization.SerialName\n")
	b.WriteString("import kotlinx.serialization.Serializable\n")
	b.WriteString("import kotlinx.serialization.json.JsonElement\n\n")

	// Type aliases with companion objects.
	for _, a := range kotlinAliases {
		fmt.Fprintf(&b, "typealias %s = String\n\n", a.name)
		fmt.Fprintf(&b, "object %s {\n", kotlinPlural(a.name))
		for _, c := range a.constants {
			fmt.Fprintf(&b, "    const val %s: %s = %q\n", c.name, a.name, c.value)
		}
		b.WriteString("}\n\n")
	}

	// Standalone type aliases.
	for _, a := range kotlinStandaloneAliases {
		fmt.Fprintf(&b, "typealias %s = %s\n\n", a.name, a.target)
	}

	// Error codes.
	b.WriteString("object ErrorCodes {\n")
	for _, c := range kotlinErrorCodes {
		fmt.Fprintf(&b, "    const val %s = %q\n", c.name, c.value)
	}
	b.WriteString("}\n\n")

	// Structs: auto-discovered from route types and their transitive fields.
	for _, ks := range discoverKotlinStructs() {
		if ks.comment != "" {
			fmt.Fprintf(&b, "// %s\n\n", ks.comment)
		}
		emitKotlinStruct(&b, ks.t)
		b.WriteString("\n")
	}

	return os.WriteFile(filepath.Join(outDir, "Types.kt"), []byte(b.String()), 0o600)
}

func writeKotlinClient(outDir string) error {
	var b strings.Builder

	// Static header and imports.
	b.WriteString(`// Code generated by gen-api-sdk. DO NOT EDIT.
package com.caic.sdk.v1

import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.Response
import okhttp3.sse.EventSource
import okhttp3.sse.EventSourceListener
import okhttp3.sse.EventSources
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class ApiException(
    val statusCode: Int,
    val code: String,
    message: String,
    val details: Map<String, kotlinx.serialization.json.JsonElement>? = null,
) : Exception(message)

class ApiClient(baseURL: String) {
    private val baseURL: String = baseURL.trimEnd('/')
    private val client = OkHttpClient()
    private val json = Json { ignoreUnknownKeys = true }
    private val jsonMediaType = "application/json".toMediaType()

    private suspend inline fun <reified T> request(method: String, path: String, body: String? = null): T {
        val url = "$baseURL$path"
        val needsBody = method in listOf("POST", "PUT", "PATCH")
        val requestBody = body?.toRequestBody(jsonMediaType)
            ?: if (needsBody) "".toRequestBody(jsonMediaType) else null
        val request = Request.Builder()
            .url(url)
            .method(method, requestBody)
            .header("Content-Type", "application/json")
            .build()
        return suspendCancellableCoroutine { cont ->
            val call = client.newCall(request)
            cont.invokeOnCancellation { call.cancel() }
            call.enqueue(object : okhttp3.Callback {
                override fun onFailure(call: okhttp3.Call, e: java.io.IOException) {
                    cont.resumeWithException(e)
                }
                override fun onResponse(call: okhttp3.Call, response: Response) {
                    response.use { resp ->
                        val responseBody = resp.body?.string() ?: ""
                        if (!resp.isSuccessful) {
                            try {
                                val err = json.decodeFromString<ErrorResponse>(responseBody)
                                cont.resumeWithException(
                                    ApiException(resp.code, err.error.code, err.error.message, err.details)
                                )
                            } catch (_: Exception) {
                                cont.resumeWithException(
                                    ApiException(resp.code, "UNKNOWN", responseBody)
                                )
                            }
                            return
                        }
                        try {
                            cont.resume(json.decodeFromString<T>(responseBody))
                        } catch (e: Exception) {
                            cont.resumeWithException(e)
                        }
                    }
                }
            })
        }
    }

`)

	// Generate JSON endpoint methods from routes.
	b.WriteString("    // JSON endpoints\n")
	for i := range v1.Routes {
		r := &v1.Routes[i]
		if r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinJSONFunc(&b, r, params)
	}
	b.WriteString("\n")

	// Generate SSE endpoint methods from routes.
	b.WriteString("    // SSE endpoints\n")
	for i := range v1.Routes {
		r := &v1.Routes[i]
		if !r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinSSEFunc(&b, r, params)
	}
	b.WriteString("\n")

	// sseFlow helper and reconnecting wrappers.
	b.WriteString(`    private inline fun <reified T> sseFlow(path: String): Flow<T> = callbackFlow {
        val request = Request.Builder()
            .url("$baseURL$path")
            .header("Accept", "text/event-stream")
            .build()
        val factory = EventSources.createFactory(client)
        val source = factory.newEventSource(request, object : EventSourceListener() {
            override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
                try {
                    val event = json.decodeFromString<T>(data)
                    trySend(event)
                } catch (_: Exception) {
                    // Skip malformed events.
                }
            }
            override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
                close(t?.let { java.io.IOException("SSE connection failed", it) })
            }
            override fun onClosed(eventSource: EventSource) {
                close()
            }
        })
        awaitClose { source.cancel() }
    }

    // Reconnecting SSE wrappers with exponential backoff.
`)

	// Generate reconnecting wrappers for SSE routes.
	for i := range v1.Routes {
		r := &v1.Routes[i]
		if !r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinReconnectingFunc(&b, r, params)
	}
	b.WriteString("\n")

	b.WriteString(`    private fun <T> reconnectingFlow(connect: () -> Flow<T>): Flow<T> = flow {
        var delayMs = 500L
        while (true) {
            try {
                connect().onEach { delayMs = 500L }.collect { emit(it) }
            } catch (e: CancellationException) {
                throw e
            } catch (_: Exception) {
                delay(delayMs)
                delayMs = (delayMs * 3 / 2).coerceAtMost(4000L)
            }
        }
    }
}
`)

	return os.WriteFile(filepath.Join(outDir, "ApiClient.kt"), []byte(b.String()), 0o600)
}

func writeKotlinJSONFunc(b *strings.Builder, r *v1.Route, params []string) {
	respType := r.RespName()
	if r.IsArray {
		respType = "List<" + respType + ">"
	}

	// Build function parameters.
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": String")
	}
	hasReq := r.Req != nil
	if hasReq {
		args = append(args, "req: "+r.ReqName())
	}

	ktPath := buildKotlinPath(r.Path, params)

	sig := strings.Join(args, ", ")
	if hasReq {
		fmt.Fprintf(b, "    suspend fun %s(%s): %s = request(%q, %s, json.encodeToString(req))\n", r.Name, sig, respType, r.Method, ktPath)
	} else {
		fmt.Fprintf(b, "    suspend fun %s(%s): %s = request(%q, %s)\n", r.Name, sig, respType, r.Method, ktPath)
	}
}

func writeKotlinSSEFunc(b *strings.Builder, r *v1.Route, params []string) {
	args := make([]string, 0, len(params))
	for _, p := range params {
		args = append(args, p+": String")
	}
	ktPath := buildKotlinPath(r.Path, params)
	respName := r.RespName()
	fmt.Fprintf(b, "    fun %s(%s): Flow<%s> = sseFlow<%s>(%s)\n", r.Name, strings.Join(args, ", "), respName, respName, ktPath)
}

func writeKotlinReconnectingFunc(b *strings.Builder, r *v1.Route, params []string) {
	// Build the function name: e.g. "taskEvents" -> "taskEventsReconnecting"
	reconnectName := r.Name + "Reconnecting"

	args := make([]string, 0, len(params))
	callArgs := make([]string, 0, len(params))
	for _, p := range params {
		args = append(args, p+": String")
		callArgs = append(callArgs, p)
	}

	fmt.Fprintf(b, "    fun %s(%s): Flow<%s> = reconnectingFlow { %s(%s) }\n",
		reconnectName, strings.Join(args, ", "), r.RespName(), r.Name, strings.Join(callArgs, ", "))
}

// buildKotlinPath returns a Kotlin string expression for the path. Uses string
// templates for paths with parameters.
func buildKotlinPath(path string, params []string) string {
	if len(params) == 0 {
		return fmt.Sprintf("%q", path)
	}
	kt := pathParamRe.ReplaceAllStringFunc(path, func(match string) string {
		name := match[1 : len(match)-1]
		return "$" + name
	})
	return fmt.Sprintf("%q", kt)
}

func extractPathParams(path string) []string {
	matches := pathParamRe.FindAllStringSubmatch(path, -1)
	out := make([]string, len(matches))
	for i, m := range matches {
		out[i] = m[1]
	}
	return out
}

// buildTSPath returns either a quoted string or a template literal for paths
// with parameters.
func buildTSPath(path string, params []string) string {
	if len(params) == 0 {
		return fmt.Sprintf("%q", path)
	}
	ts := pathParamRe.ReplaceAllStringFunc(path, func(match string) string {
		name := match[1 : len(match)-1]
		return "${" + name + "}"
	})
	return "`" + ts + "`"
}

// generateDoc generates sdk/API.md from the route table.
func generateDoc(outDir string) error {
	var b strings.Builder
	b.WriteString("# caic API Reference\n\n")
	b.WriteString("<!-- Code generated by gen-api-sdk; DO NOT EDIT. -->\n\n")
	b.WriteString("RESTful JSON API served at `/api/v1/`. SSE endpoints stream newline-delimited JSON events.\n\n")

	groups := docGroupRoutes(v1.Routes)

	// Route tables.
	for _, g := range groups {
		fmt.Fprintf(&b, "## %s\n\n", g.name)
		b.WriteString("| Method | Path | Request | Response |\n")
		b.WriteString("|--------|------|---------|----------|\n")
		for _, r := range g.routes {
			req := ""
			if r.Req != nil {
				req = "`" + r.ReqName() + "`"
			}
			resp := "`" + r.RespName() + "`"
			if r.IsArray {
				resp = "`" + r.RespName() + "[]`"
			}
			if r.IsSSE {
				resp += " SSE"
			}
			fmt.Fprintf(&b, "| %s | `%s` | %s | %s |\n", r.Method, r.Path, req, resp)
		}
		b.WriteString("\n")
	}

	// Errors section.
	b.WriteString("## Errors\n\n")
	b.WriteString("All errors return:\n\n")
	b.WriteString("```json\n")
	b.WriteString("{\n")
	b.WriteString("  \"error\": { \"code\": \"<CODE>\", \"message\": \"...\" },\n")
	b.WriteString("  \"details\": { ... }\n")
	b.WriteString("}\n")
	b.WriteString("```\n\n")
	b.WriteString("| HTTP | Code |\n")
	b.WriteString("|------|------|\n")
	b.WriteString("| 400 | `BAD_REQUEST` |\n")
	b.WriteString("| 404 | `NOT_FOUND` |\n")
	b.WriteString("| 409 | `CONFLICT` |\n")
	b.WriteString("| 500 | `INTERNAL_ERROR` |\n\n")

	// Types section.
	b.WriteString("## Types\n\n")
	for _, t := range discoverDocTypes() {
		writeDocType(&b, t)
	}

	return os.WriteFile(filepath.Join(outDir, "API.md"), []byte(b.String()), 0o600)
}

type docRouteGroup struct {
	name   string
	routes []v1.Route
}

// docGroupRoutes groups routes by CategoryName(), preserving first-seen order.
func docGroupRoutes(routes []v1.Route) []docRouteGroup {
	seen := map[string]int{} // category name → index in result
	var result []docRouteGroup
	for i := range routes {
		r := &routes[i]
		cat := r.CategoryName()
		if idx, ok := seen[cat]; ok {
			result[idx].routes = append(result[idx].routes, *r)
		} else {
			seen[cat] = len(result)
			result = append(result, docRouteGroup{name: cat, routes: []v1.Route{*r}})
		}
	}
	return result
}

// discoverDocTypes returns all dto struct types reachable from Routes in
// dependency order (leaves first).
func discoverDocTypes() []reflect.Type {
	seen := map[reflect.Type]bool{}
	var order []reflect.Type

	var walk func(t reflect.Type)
	walk = func(t reflect.Type) {
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}
		if t.Kind() == reflect.Slice {
			walk(t.Elem())
			return
		}
		if t.Kind() != reflect.Struct || !isSDKPkg(t.PkgPath()) {
			return
		}
		if seen[t] {
			return
		}
		seen[t] = true
		for i := range t.NumField() {
			walk(t.Field(i).Type)
		}
		order = append(order, t)
	}

	for i := range v1.Routes {
		r := &v1.Routes[i]
		if r.Req != nil {
			walk(r.Req)
		}
		walk(r.Resp)
	}
	return order
}

func writeDocType(b *strings.Builder, t reflect.Type) {
	fmt.Fprintf(b, "### %s\n\n", t.Name())
	b.WriteString("| Field | Type | Required |\n")
	b.WriteString("|-------|------|----------|\n")
	for i := range t.NumField() {
		sf := t.Field(i)
		if !sf.IsExported() {
			continue
		}
		tag := sf.Tag.Get("json")
		if tag == "-" {
			continue
		}
		jsonName, opts := parseJSONTag(tag)
		if jsonName == "" {
			jsonName = sf.Name
		}
		optional := opts.contains("omitempty") || opts.contains("omitzero") || sf.Type.Kind() == reflect.Ptr
		typeName := goTypeToDoc(sf.Type)
		req := "yes"
		if optional {
			req = ""
		}
		fmt.Fprintf(b, "| `%s` | `%s` | %s |\n", jsonName, typeName, req)
	}
	b.WriteString("\n")
}

// goTypeToDoc maps a Go reflect.Type to a TypeScript-style string for docs.
func goTypeToDoc(t reflect.Type) string {
	if t.Kind() == reflect.Ptr {
		return goTypeToDoc(t.Elem())
	}
	switch t {
	case diffStatType:
		return "DiffFileStat[]"
	case ksidIDType:
		return "string"
	case jsonRawMessageType:
		return "object"
	}
	switch t.Kind() {
	case reflect.String:
		return "string"
	case reflect.Int, reflect.Int64, reflect.Float64:
		return "number"
	case reflect.Bool:
		return "boolean"
	case reflect.Slice:
		return goTypeToDoc(t.Elem()) + "[]"
	case reflect.Struct:
		return t.Name()
	case reflect.Map:
		return "Record<string, unknown>"
	default:
		return t.Name()
	}
}

func sortedKeys(m map[string]struct{}) []string {
	out := make([]string, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	// Simple insertion sort for a small set.
	for i := 1; i < len(out); i++ {
		for j := i; j > 0 && out[j] < out[j-1]; j-- {
			out[j], out[j-1] = out[j-1], out[j]
		}
	}
	return out
}
