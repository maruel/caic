// Generates a typed API client from the Go route declarations. Supports
// TypeScript (--lang=ts, default) and Kotlin (--lang=kotlin) output.
package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
	"unicode"

	"github.com/maruel/caic/backend/internal/server/dto"
	"github.com/maruel/ksid"
)

var pathParamRe = regexp.MustCompile(`\{(\w+)\}`)

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run() error {
	lang := flag.String("lang", "ts", "output language: ts or kotlin")
	out := flag.String("out", "", "output directory (default: sdk/ relative to repo root for ts)")
	flag.Parse()

	switch *lang {
	case "ts", "":
		outDir := *out
		if outDir == "" {
			// Relative to go:generate CWD (backend/internal/server/dto/).
			outDir = "../../../../sdk"
		}
		return generateTS(outDir)
	case "kotlin":
		outDir := *out
		if outDir == "" {
			return errors.New("--out is required for --lang=kotlin")
		}
		return generateKotlin(outDir)
	default:
		return fmt.Errorf("unsupported language: %s", *lang)
	}
}

// generateTS generates the TypeScript API client (existing behavior).
func generateTS(outDir string) error {
	// Collect all referenced types for the import statement.
	types := map[string]struct{}{}
	for _, r := range dto.Routes {
		if r.ReqType != "" {
			types[r.ReqType] = struct{}{}
		}
		if r.RespType != "" {
			types[r.RespType] = struct{}{}
		}
	}
	types["ErrorResponse"] = struct{}{}

	sorted := sortedKeys(types)

	var b strings.Builder
	b.WriteString("// Code generated by gen-api-client. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "import type { %s } from \"./types.gen\";\n\n", strings.Join(sorted, ", "))

	// APIError class.
	b.WriteString(`export class APIError extends Error {
  constructor(
    public status: number,
    public code: string,
    public details?: Record<string, unknown>,
  ) {
    super(code);
  }
}

`)

	// Generic request helper.
	b.WriteString(`async function request<T>(method: string, path: string, body?: unknown): Promise<T> {
  const init: RequestInit = { method, headers: { "Content-Type": "application/json" } };
  if (body !== undefined) init.body = JSON.stringify(body);
  const res = await fetch(path, init);
  if (!res.ok) {
    const err = (await res.json()) as ErrorResponse;
    const e = new APIError(res.status, err.error.code, err.details);
    e.message = err.error.message;
    throw e;
  }
  return res.json() as Promise<T>;
}

`)

	// One function per route.
	for i := range dto.Routes {
		r := &dto.Routes[i]
		params := extractPathParams(r.Path)
		if r.IsSSE {
			writeTSSSEFunc(&b, r, params)
		} else {
			writeTSJSONFunc(&b, r, params)
		}
	}

	return os.WriteFile(filepath.Join(outDir, "api.gen.ts"), []byte(b.String()), 0o600)
}

func writeTSJSONFunc(b *strings.Builder, r *dto.Route, params []string) {
	respType := r.RespType
	if r.IsArray {
		respType += "[]"
	}

	// Build function signature.
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	if r.ReqType != "" {
		args = append(args, "req: "+r.ReqType)
	}

	tsPath := buildTSPath(r.Path, params)

	fmt.Fprintf(b, "export function %s(%s): Promise<%s> {\n", r.Name, strings.Join(args, ", "), respType)
	if r.ReqType != "" {
		fmt.Fprintf(b, "  return request<%s>(%q, %s, req);\n", respType, r.Method, tsPath)
	} else {
		fmt.Fprintf(b, "  return request<%s>(%q, %s);\n", respType, r.Method, tsPath)
	}
	b.WriteString("}\n\n")
}

func writeTSSSEFunc(b *strings.Builder, r *dto.Route, params []string) {
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	tsPath := buildTSPath(r.Path, params)
	if r.RespType != "" {
		args = append(args, "onMessage: (event: "+r.RespType+") => void")
		fmt.Fprintf(b, "export function %s(%s): EventSource {\n", r.Name, strings.Join(args, ", "))
		fmt.Fprintf(b, "  const es = new EventSource(%s);\n", tsPath)
		b.WriteString("  es.addEventListener(\"message\", (e) => {\n")
		fmt.Fprintf(b, "    onMessage(JSON.parse(e.data) as %s);\n", r.RespType)
		b.WriteString("  });\n")
		b.WriteString("  return es;\n")
	} else {
		fmt.Fprintf(b, "export function %s(%s): EventSource {\n", r.Name, strings.Join(args, ", "))
		fmt.Fprintf(b, "  return new EventSource(%s);\n", tsPath)
	}
	b.WriteString("}\n\n")
}

// generateKotlin generates Types.kt and ApiClient.kt in outDir.
func generateKotlin(outDir string) error {
	if err := os.MkdirAll(outDir, 0o750); err != nil {
		return err
	}
	if err := writeKotlinTypes(outDir); err != nil {
		return err
	}
	return writeKotlinClient(outDir)
}

// kotlinTypeAlias describes a `typealias X = String` with an optional
// companion object holding constants.
type kotlinTypeAlias struct {
	name      string
	constants []kotlinConstant
}

// kotlinConstant is a single `const val Name: Type = "value"` entry.
type kotlinConstant struct {
	name  string
	value string
}

// kotlinStruct wraps a reflect.Type with an optional section comment that
// appears before the struct in the generated output.
type kotlinStruct struct {
	t       reflect.Type
	comment string // Emitted as `// comment` before the struct.
}

// kotlinField holds parsed information about a single struct field for Kotlin
// code generation.
type kotlinField struct {
	jsonName   string // JSON key from the struct tag.
	ktName     string // Kotlin property name (same as jsonName).
	ktType     string // Kotlin type (e.g. "String", "List<Foo>").
	nullable   bool   // Whether the field is T? = null.
	serialName string // Non-empty when @SerialName annotation is needed.
}

// Type aliases: typealias + companion object with constants.
var kotlinAliases = []kotlinTypeAlias{
	{
		name: "Harness",
		constants: []kotlinConstant{
			{"Claude", string(dto.HarnessClaude)},
			{"Gemini", string(dto.HarnessGemini)},
		},
	},
	{
		name: "EventKind",
		constants: []kotlinConstant{
			{"Init", string(dto.EventKindInit)},
			{"Text", string(dto.EventKindText)},
			{"TextDelta", string(dto.EventKindTextDelta)},
			{"ToolUse", string(dto.EventKindToolUse)},
			{"ToolResult", string(dto.EventKindToolResult)},
			{"Ask", string(dto.EventKindAsk)},
			{"Usage", string(dto.EventKindUsage)},
			{"Result", string(dto.EventKindResult)},
			{"System", string(dto.EventKindSystem)},
			{"UserInput", string(dto.EventKindUserInput)},
			{"Todo", string(dto.EventKindTodo)},
			{"DiffStat", string(dto.EventKindDiffStat)},
		},
	},
}

// Standalone type alias without constants.
var kotlinStandaloneAliases = []struct {
	name   string
	target string
}{
	{"ClaudeEventKind", "EventKind"},
}

// Error code constants.
var kotlinErrorCodes = []kotlinConstant{
	{"BadRequest", string(dto.CodeBadRequest)},
	{"NotFound", string(dto.CodeNotFound)},
	{"Conflict", string(dto.CodeConflict)},
	{"InternalError", string(dto.CodeInternalError)},
}

// Ordered list of structs to generate. Adding a new Go struct requires adding
// one line here; field definitions are derived automatically via reflect.
var kotlinStructs = []kotlinStruct{
	{t: reflect.TypeFor[dto.HarnessJSON]()},
	{t: reflect.TypeFor[dto.ConfigJSON]()},
	{t: reflect.TypeFor[dto.RepoJSON]()},
	{t: reflect.TypeFor[dto.TaskJSON]()},
	{t: reflect.TypeFor[dto.StatusResp]()},
	{t: reflect.TypeFor[dto.CreateTaskResp]()},
	{t: reflect.TypeFor[dto.CreateTaskReq]()},
	{t: reflect.TypeFor[dto.InputReq]()},
	{t: reflect.TypeFor[dto.RestartReq]()},
	{t: reflect.TypeFor[dto.DiffFileStat]()},
	{t: reflect.TypeFor[dto.SafetyIssue]()},
	{t: reflect.TypeFor[dto.SyncReq]()},
	{t: reflect.TypeFor[dto.SyncResp]()},
	{t: reflect.TypeFor[dto.UsageWindow]()},
	{t: reflect.TypeFor[dto.ExtraUsage]()},
	{t: reflect.TypeFor[dto.UsageResp]()},
	{t: reflect.TypeFor[dto.VoiceTokenResp]()},
	{t: reflect.TypeFor[dto.EventMessage](), comment: "Backend-neutral event types"},
	{t: reflect.TypeFor[dto.EventInit]()},
	{t: reflect.TypeFor[dto.EventText]()},
	{t: reflect.TypeFor[dto.EventTextDelta]()},
	{t: reflect.TypeFor[dto.EventToolUse]()},
	{t: reflect.TypeFor[dto.EventToolResult]()},
	{t: reflect.TypeFor[dto.AskOption]()},
	{t: reflect.TypeFor[dto.AskQuestion]()},
	{t: reflect.TypeFor[dto.EventAsk]()},
	{t: reflect.TypeFor[dto.EventUsage]()},
	{t: reflect.TypeFor[dto.EventResult]()},
	{t: reflect.TypeFor[dto.EventSystem]()},
	{t: reflect.TypeFor[dto.EventUserInput]()},
	{t: reflect.TypeFor[dto.TodoItem]()},
	{t: reflect.TypeFor[dto.EventTodo]()},
	{t: reflect.TypeFor[dto.EventDiffStat]()},
	{t: reflect.TypeFor[dto.ClaudeEventMessage](), comment: "Claude-specific event types"},
	{t: reflect.TypeFor[dto.ClaudeEventInit]()},
	{t: reflect.TypeFor[dto.ClaudeEventText]()},
	{t: reflect.TypeFor[dto.ClaudeEventTextDelta]()},
	{t: reflect.TypeFor[dto.ClaudeEventToolUse]()},
	{t: reflect.TypeFor[dto.ClaudeEventToolResult]()},
	{t: reflect.TypeFor[dto.ClaudeAskOption]()},
	{t: reflect.TypeFor[dto.ClaudeAskQuestion]()},
	{t: reflect.TypeFor[dto.ClaudeEventAsk]()},
	{t: reflect.TypeFor[dto.ClaudeEventUsage]()},
	{t: reflect.TypeFor[dto.ClaudeEventResult]()},
	{t: reflect.TypeFor[dto.ClaudeEventSystem]()},
	{t: reflect.TypeFor[dto.ClaudeEventUserInput]()},
	{t: reflect.TypeFor[dto.ClaudeTodoItem]()},
	{t: reflect.TypeFor[dto.ClaudeEventTodo]()},
	{t: reflect.TypeFor[dto.ClaudeEventDiffStat]()},
	{t: reflect.TypeFor[dto.ErrorResponse]()},
	{t: reflect.TypeFor[dto.ErrorDetails]()},
}

// Type identity values for special-case mapping in goTypeToKotlin.
var (
	jsonRawMessageType = reflect.TypeFor[json.RawMessage]()
	ksidIDType         = reflect.TypeFor[ksid.ID]()
	diffStatType       = reflect.TypeFor[dto.DiffStat]()
	mapStringAnyType   = reflect.TypeFor[map[string]any]()
)

// kotlinAliasNames is the set of Go named-string types that map to their
// Kotlin typealias name rather than "String".
var kotlinAliasNames = map[reflect.Type]string{
	reflect.TypeFor[dto.Harness]():         "Harness",
	reflect.TypeFor[dto.EventKind]():       "EventKind",
	reflect.TypeFor[dto.ClaudeEventKind](): "ClaudeEventKind",
}

// kotlinPlural returns the plural object name for a type alias.
var kotlinPluralOverrides = map[string]string{
	"Harness": "Harnesses",
}

func kotlinPlural(name string) string {
	if p, ok := kotlinPluralOverrides[name]; ok {
		return p
	}
	return name + "s"
}

// goTypeToKotlin maps a Go reflect.Type to its Kotlin type string.
func goTypeToKotlin(t reflect.Type) string {
	// Unwrap pointer — nullability is handled by the caller.
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	// Special cases.
	switch t {
	case jsonRawMessageType:
		return "JsonElement"
	case ksidIDType:
		return "String"
	case diffStatType:
		return "List<DiffFileStat>"
	case mapStringAnyType:
		return "Map<String, JsonElement>"
	}

	// Named string aliases (Harness, EventKind, ClaudeEventKind).
	if name, ok := kotlinAliasNames[t]; ok {
		return name
	}

	switch t.Kind() {
	case reflect.String:
		return "String"
	case reflect.Int:
		return "Int"
	case reflect.Int64:
		return "Long"
	case reflect.Float64:
		return "Double"
	case reflect.Bool:
		return "Boolean"
	case reflect.Slice:
		return "List<" + goTypeToKotlin(t.Elem()) + ">"
	case reflect.Struct:
		return t.Name()
	default:
		return t.Name()
	}
}

// parseStructFields extracts kotlinField entries from a reflect.Type.
func parseStructFields(t reflect.Type) []kotlinField {
	fields := make([]kotlinField, 0, t.NumField())
	for i := range t.NumField() {
		sf := t.Field(i)
		if !sf.IsExported() {
			continue
		}
		tag := sf.Tag.Get("json")
		if tag == "-" {
			continue
		}
		jsonName, opts := parseJSONTag(tag)
		if jsonName == "" {
			jsonName = sf.Name
		}
		omit := opts.contains("omitempty") || opts.contains("omitzero")

		ft := sf.Type
		isPtr := ft.Kind() == reflect.Ptr

		ktType := goTypeToKotlin(ft)
		nullable := isPtr || (omit && !isPtr)

		sn := ""
		if needsSerialName(jsonName) {
			sn = jsonName
		}

		fields = append(fields, kotlinField{
			jsonName:   jsonName,
			ktName:     jsonName,
			ktType:     ktType,
			nullable:   nullable,
			serialName: sn,
		})
	}
	return fields
}

// needsSerialName returns true when the JSON name contains a run of two or
// more consecutive uppercase ASCII letters (e.g. "repoURL", "sessionID",
// "costUSD", "durationAPIMs"). Kotlin properties use these names as-is, but
// kotlinx.serialization would mangle them without an explicit @SerialName.
func needsSerialName(name string) bool {
	consecutive := 0
	for _, r := range name {
		if unicode.IsUpper(r) {
			consecutive++
			if consecutive >= 2 {
				return true
			}
		} else {
			consecutive = 0
		}
	}
	return false
}

// emitKotlinStruct writes a @Serializable data class to b.
func emitKotlinStruct(b *strings.Builder, t reflect.Type) {
	fields := parseStructFields(t)
	name := t.Name()

	// Compact single-line form for structs with ≤2 fields and no @SerialName.
	if len(fields) <= 2 && !fieldsNeedAnnotation(fields) {
		b.WriteString("@Serializable\n")
		fmt.Fprintf(b, "data class %s(", name)
		for i := range fields {
			if i > 0 {
				b.WriteString(", ")
			}
			writeFieldDecl(b, &fields[i])
		}
		b.WriteString(")\n")
		return
	}

	b.WriteString("@Serializable\n")
	fmt.Fprintf(b, "data class %s(\n", name)
	for i := range fields {
		f := &fields[i]
		b.WriteString("    ")
		if f.serialName != "" {
			fmt.Fprintf(b, "@SerialName(%q) ", f.serialName)
		}
		writeFieldDecl(b, f)
		b.WriteString(",\n")
	}
	b.WriteString(")\n")
}

// writeFieldDecl writes a single "val name: Type" (with optional "? = null").
func writeFieldDecl(b *strings.Builder, f *kotlinField) {
	if f.nullable {
		fmt.Fprintf(b, "val %s: %s? = null", f.ktName, f.ktType)
	} else {
		fmt.Fprintf(b, "val %s: %s", f.ktName, f.ktType)
	}
}

// fieldsNeedAnnotation returns true if any field requires @SerialName.
func fieldsNeedAnnotation(fields []kotlinField) bool {
	for _, f := range fields {
		if f.serialName != "" {
			return true
		}
	}
	return false
}

// parseJSONTag splits a json struct tag value into name and options.
func parseJSONTag(tag string) (string, jsonTagOptions) {
	if name, rest, ok := strings.Cut(tag, ","); ok {
		return name, jsonTagOptions(rest)
	}
	return tag, ""
}

type jsonTagOptions string

func (o jsonTagOptions) contains(opt string) bool {
	s := string(o)
	for s != "" {
		var name string
		name, s, _ = strings.Cut(s, ",")
		if name == opt {
			return true
		}
	}
	return false
}

func writeKotlinTypes(outDir string) error {
	var b strings.Builder
	b.WriteString("// Code generated by gen-api-client. DO NOT EDIT.\n")
	b.WriteString("package com.caic.sdk\n\n")
	b.WriteString("import kotlinx.serialization.SerialName\n")
	b.WriteString("import kotlinx.serialization.Serializable\n")
	b.WriteString("import kotlinx.serialization.json.JsonElement\n\n")

	// Type aliases with companion objects.
	for _, a := range kotlinAliases {
		fmt.Fprintf(&b, "typealias %s = String\n\n", a.name)
		fmt.Fprintf(&b, "object %s {\n", kotlinPlural(a.name))
		for _, c := range a.constants {
			fmt.Fprintf(&b, "    const val %s: %s = %q\n", c.name, a.name, c.value)
		}
		b.WriteString("}\n\n")
	}

	// Standalone type aliases.
	for _, a := range kotlinStandaloneAliases {
		fmt.Fprintf(&b, "typealias %s = %s\n\n", a.name, a.target)
	}

	// Error codes.
	b.WriteString("object ErrorCodes {\n")
	for _, c := range kotlinErrorCodes {
		fmt.Fprintf(&b, "    const val %s = %q\n", c.name, c.value)
	}
	b.WriteString("}\n\n")

	// Structs.
	for _, ks := range kotlinStructs {
		if ks.comment != "" {
			fmt.Fprintf(&b, "// %s\n\n", ks.comment)
		}
		emitKotlinStruct(&b, ks.t)
		b.WriteString("\n")
	}

	return os.WriteFile(filepath.Join(outDir, "Types.kt"), []byte(b.String()), 0o600)
}

func writeKotlinClient(outDir string) error {
	var b strings.Builder

	// Static header and imports.
	b.WriteString(`// Code generated by gen-api-client. DO NOT EDIT.
package com.caic.sdk

import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.Response
import okhttp3.sse.EventSource
import okhttp3.sse.EventSourceListener
import okhttp3.sse.EventSources
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class ApiException(
    val statusCode: Int,
    val code: String,
    message: String,
    val details: Map<String, kotlinx.serialization.json.JsonElement>? = null,
) : Exception(message)

class ApiClient(baseURL: String) {
    private val baseURL: String = baseURL.trimEnd('/')
    private val client = OkHttpClient()
    private val json = Json { ignoreUnknownKeys = true }
    private val jsonMediaType = "application/json".toMediaType()

    private suspend inline fun <reified T> request(method: String, path: String, body: String? = null): T {
        val url = "$baseURL$path"
        val requestBody = body?.toRequestBody(jsonMediaType)
        val request = Request.Builder()
            .url(url)
            .method(method, requestBody)
            .header("Content-Type", "application/json")
            .build()
        return suspendCancellableCoroutine { cont ->
            val call = client.newCall(request)
            cont.invokeOnCancellation { call.cancel() }
            call.enqueue(object : okhttp3.Callback {
                override fun onFailure(call: okhttp3.Call, e: java.io.IOException) {
                    cont.resumeWithException(e)
                }
                override fun onResponse(call: okhttp3.Call, response: Response) {
                    response.use { resp ->
                        val responseBody = resp.body?.string() ?: ""
                        if (!resp.isSuccessful) {
                            try {
                                val err = json.decodeFromString<ErrorResponse>(responseBody)
                                cont.resumeWithException(
                                    ApiException(resp.code, err.error.code, err.error.message, err.details)
                                )
                            } catch (_: Exception) {
                                cont.resumeWithException(
                                    ApiException(resp.code, "UNKNOWN", responseBody)
                                )
                            }
                            return
                        }
                        try {
                            cont.resume(json.decodeFromString<T>(responseBody))
                        } catch (e: Exception) {
                            cont.resumeWithException(e)
                        }
                    }
                }
            })
        }
    }

`)

	// Generate JSON endpoint methods from routes.
	b.WriteString("    // JSON endpoints\n")
	for i := range dto.Routes {
		r := &dto.Routes[i]
		if r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinJSONFunc(&b, r, params)
	}
	b.WriteString("\n")

	// Generate SSE endpoint methods from routes.
	b.WriteString("    // SSE endpoints\n")
	for i := range dto.Routes {
		r := &dto.Routes[i]
		if !r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinSSEFunc(&b, r, params)
	}
	// Static globalEvents (not in routes but part of the API surface).
	b.WriteString("    fun globalEvents(): Flow<EventMessage> = sseFlow<EventMessage>(\"/api/v1/events\")\n")
	b.WriteString("\n")

	// sseFlow helper and reconnecting wrappers.
	b.WriteString(`    private inline fun <reified T> sseFlow(path: String): Flow<T> = callbackFlow {
        val request = Request.Builder()
            .url("$baseURL$path")
            .header("Accept", "text/event-stream")
            .build()
        val factory = EventSources.createFactory(client)
        val source = factory.newEventSource(request, object : EventSourceListener() {
            override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
                try {
                    val event = json.decodeFromString<T>(data)
                    trySend(event)
                } catch (_: Exception) {
                    // Skip malformed events.
                }
            }
            override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
                close(t?.let { java.io.IOException("SSE connection failed", it) })
            }
            override fun onClosed(eventSource: EventSource) {
                close()
            }
        })
        awaitClose { source.cancel() }
    }

    // Reconnecting SSE wrappers with exponential backoff.
`)

	// Generate reconnecting wrappers for SSE routes.
	for i := range dto.Routes {
		r := &dto.Routes[i]
		if !r.IsSSE {
			continue
		}
		params := extractPathParams(r.Path)
		writeKotlinReconnectingFunc(&b, r, params)
	}
	// Static globalEventsReconnecting.
	b.WriteString("    fun globalEventsReconnecting(): Flow<EventMessage> = reconnectingFlow { globalEvents() }\n")
	b.WriteString("\n")

	b.WriteString(`    private fun <T> reconnectingFlow(connect: () -> Flow<T>): Flow<T> = flow {
        var delayMs = 500L
        while (true) {
            try {
                connect().onEach { delayMs = 500L }.collect { emit(it) }
            } catch (e: CancellationException) {
                throw e
            } catch (_: Exception) {
                delay(delayMs)
                delayMs = (delayMs * 3 / 2).coerceAtMost(4000L)
            }
        }
    }
}
`)

	return os.WriteFile(filepath.Join(outDir, "ApiClient.kt"), []byte(b.String()), 0o600)
}

func writeKotlinJSONFunc(b *strings.Builder, r *dto.Route, params []string) {
	respType := r.RespType
	if r.IsArray {
		respType = "List<" + respType + ">"
	}

	// Build function parameters.
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": String")
	}
	if r.ReqType != "" {
		args = append(args, "req: "+r.ReqType)
	}

	ktPath := buildKotlinPath(r.Path, params)

	sig := strings.Join(args, ", ")
	if r.ReqType != "" {
		fmt.Fprintf(b, "    suspend fun %s(%s): %s = request(%q, %s, json.encodeToString(req))\n", r.Name, sig, respType, r.Method, ktPath)
	} else {
		fmt.Fprintf(b, "    suspend fun %s(%s): %s = request(%q, %s)\n", r.Name, sig, respType, r.Method, ktPath)
	}
}

func writeKotlinSSEFunc(b *strings.Builder, r *dto.Route, params []string) {
	args := make([]string, 0, len(params))
	for _, p := range params {
		args = append(args, p+": String")
	}
	ktPath := buildKotlinPath(r.Path, params)
	fmt.Fprintf(b, "    fun %s(%s): Flow<%s> = sseFlow<%s>(%s)\n", r.Name, strings.Join(args, ", "), r.RespType, r.RespType, ktPath)
}

func writeKotlinReconnectingFunc(b *strings.Builder, r *dto.Route, params []string) {
	// Build the function name: e.g. "taskEvents" -> "taskEventsReconnecting"
	reconnectName := r.Name + "Reconnecting"

	args := make([]string, 0, len(params))
	callArgs := make([]string, 0, len(params))
	for _, p := range params {
		args = append(args, p+": String")
		callArgs = append(callArgs, p)
	}

	fmt.Fprintf(b, "    fun %s(%s): Flow<%s> = reconnectingFlow { %s(%s) }\n",
		reconnectName, strings.Join(args, ", "), r.RespType, r.Name, strings.Join(callArgs, ", "))
}

// buildKotlinPath returns a Kotlin string expression for the path. Uses string
// templates for paths with parameters.
func buildKotlinPath(path string, params []string) string {
	if len(params) == 0 {
		return fmt.Sprintf("%q", path)
	}
	kt := pathParamRe.ReplaceAllStringFunc(path, func(match string) string {
		name := match[1 : len(match)-1]
		return "$" + name
	})
	return fmt.Sprintf("%q", kt)
}

func extractPathParams(path string) []string {
	matches := pathParamRe.FindAllStringSubmatch(path, -1)
	out := make([]string, len(matches))
	for i, m := range matches {
		out[i] = m[1]
	}
	return out
}

// buildTSPath returns either a quoted string or a template literal for paths
// with parameters.
func buildTSPath(path string, params []string) string {
	if len(params) == 0 {
		return fmt.Sprintf("%q", path)
	}
	ts := pathParamRe.ReplaceAllStringFunc(path, func(match string) string {
		name := match[1 : len(match)-1]
		return "${" + name + "}"
	})
	return "`" + ts + "`"
}

func sortedKeys(m map[string]struct{}) []string {
	out := make([]string, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	// Simple insertion sort for a small set.
	for i := 1; i < len(out); i++ {
		for j := i; j > 0 && out[j] < out[j-1]; j-- {
			out[j], out[j-1] = out[j-1], out[j]
		}
	}
	return out
}
