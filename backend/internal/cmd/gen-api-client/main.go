// Generates a typed TypeScript API client from the Go route declarations.
package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/maruel/wmao/backend/internal/server/dto"
)

var pathParamRe = regexp.MustCompile(`\{(\w+)\}`)

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run() error {
	// Collect all referenced types for the import statement.
	types := map[string]struct{}{}
	for _, r := range dto.Routes {
		if r.ReqType != "" {
			types[r.ReqType] = struct{}{}
		}
		if r.RespType != "" {
			types[r.RespType] = struct{}{}
		}
	}
	types["ErrorResponse"] = struct{}{}

	sorted := sortedKeys(types)

	var b strings.Builder
	b.WriteString("// Code generated by gen-api-client. DO NOT EDIT.\n")
	fmt.Fprintf(&b, "import type { %s } from \"./types.gen\";\n\n", strings.Join(sorted, ", "))

	// APIError class.
	b.WriteString(`export class APIError extends Error {
  constructor(
    public status: number,
    public code: string,
    public details?: Record<string, unknown>,
  ) {
    super(code);
  }
}

`)

	// Generic request helper.
	b.WriteString(`async function request<T>(method: string, path: string, body?: unknown): Promise<T> {
  const init: RequestInit = { method, headers: { "Content-Type": "application/json" } };
  if (body !== undefined) init.body = JSON.stringify(body);
  const res = await fetch(path, init);
  if (!res.ok) {
    const err = (await res.json()) as ErrorResponse;
    throw new APIError(res.status, err.error.code, err.details);
  }
  return res.json() as Promise<T>;
}

`)

	// One function per route.
	for i := range dto.Routes {
		r := &dto.Routes[i]
		params := extractPathParams(r.Path)
		if r.IsSSE {
			writeSSEFunc(&b, r, params)
		} else {
			writeJSONFunc(&b, r, params)
		}
	}

	// Relative to go:generate CWD (backend/internal/server/dto/).
	return os.WriteFile("../../../../sdk/api.gen.ts", []byte(b.String()), 0o600)
}

func writeJSONFunc(b *strings.Builder, r *dto.Route, params []string) {
	respType := r.RespType
	if r.IsArray {
		respType += "[]"
	}

	// Build function signature.
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	if r.ReqType != "" {
		args = append(args, "req: "+r.ReqType)
	}

	tsPath := buildTSPath(r.Path, params)

	fmt.Fprintf(b, "export function %s(%s): Promise<%s> {\n", r.Name, strings.Join(args, ", "), respType)
	if r.ReqType != "" {
		fmt.Fprintf(b, "  return request<%s>(%q, %s, req);\n", respType, r.Method, tsPath)
	} else {
		fmt.Fprintf(b, "  return request<%s>(%q, %s);\n", respType, r.Method, tsPath)
	}
	b.WriteString("}\n\n")
}

func writeSSEFunc(b *strings.Builder, r *dto.Route, params []string) {
	args := make([]string, 0, len(params)+1)
	for _, p := range params {
		args = append(args, p+": string")
	}
	tsPath := buildTSPath(r.Path, params)
	if r.RespType != "" {
		args = append(args, "onMessage: (event: "+r.RespType+") => void")
		fmt.Fprintf(b, "export function %s(%s): EventSource {\n", r.Name, strings.Join(args, ", "))
		fmt.Fprintf(b, "  const es = new EventSource(%s);\n", tsPath)
		b.WriteString("  es.addEventListener(\"message\", (e) => {\n")
		fmt.Fprintf(b, "    onMessage(JSON.parse(e.data) as %s);\n", r.RespType)
		b.WriteString("  });\n")
		b.WriteString("  return es;\n")
	} else {
		fmt.Fprintf(b, "export function %s(%s): EventSource {\n", r.Name, strings.Join(args, ", "))
		fmt.Fprintf(b, "  return new EventSource(%s);\n", tsPath)
	}
	b.WriteString("}\n\n")
}

func extractPathParams(path string) []string {
	matches := pathParamRe.FindAllStringSubmatch(path, -1)
	out := make([]string, len(matches))
	for i, m := range matches {
		out[i] = m[1]
	}
	return out
}

// buildTSPath returns either a quoted string or a template literal for paths
// with parameters.
func buildTSPath(path string, params []string) string {
	if len(params) == 0 {
		return fmt.Sprintf("%q", path)
	}
	ts := pathParamRe.ReplaceAllStringFunc(path, func(match string) string {
		name := match[1 : len(match)-1]
		return "${" + name + "}"
	})
	return "`" + ts + "`"
}

func sortedKeys(m map[string]struct{}) []string {
	out := make([]string, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	// Simple insertion sort for a small set.
	for i := 1; i < len(out); i++ {
		for j := i; j > 0 && out[j] < out[j-1]; j-- {
			out[j], out[j-1] = out[j-1], out[j]
		}
	}
	return out
}
